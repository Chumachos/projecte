<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script type="text/javascript">(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(d){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})()
</script>
<script type="text/javascript">var KX_timer = new window.jstiming.Timer(); KX_timer.name = 'published';</script><title>systemd journal</title><link rel="shortcut icon" href="https://ssl.gstatic.com/docs/documents/images/kix-favicon6.ico"><style type="text/css">
      body {
        font-family: arial, sans, sans-serif;
        margin: 0;
      }

      iframe {
        border: 0;
        frameborder: 0;
        height: 100%;
        width: 100%;
      }

      #header, #footer {
        background: #f0f0f0;
        padding: 10px 10px;
      }

      #header {
        border-bottom: 1px #ccc solid;
      }

      #footer {
        border-top: 1px #ccc solid;
        border-bottom: 1px #ccc solid;
        font-size: 13;
      }

      #contents {
        margin: 6px;
      }

      .dash {
        padding: 0 6px;
      }
    </style></head><body><div id="header">systemd journal</div><div id="contents"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');.lst-kix_8aentbnft-2>li{counter-increment:lst-ctn-kix_8aentbnft-2}ol.lst-kix_8aentbnft-6.start{counter-reset:lst-ctn-kix_8aentbnft-6 0}.lst-kix_igitig4ztshe-0>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-0,decimal) ". "}ol.lst-kix_igitig4ztshe-1.start{counter-reset:lst-ctn-kix_igitig4ztshe-1 0}.lst-kix_igitig4ztshe-4>li{counter-increment:lst-ctn-kix_igitig4ztshe-4}.lst-kix_8aentbnft-1>li{counter-increment:lst-ctn-kix_8aentbnft-1}ol.lst-kix_8aentbnft-2.start{counter-reset:lst-ctn-kix_8aentbnft-2 0}ol.lst-kix_8aentbnft-3.start{counter-reset:lst-ctn-kix_8aentbnft-3 0}ol.lst-kix_igitig4ztshe-4.start{counter-reset:lst-ctn-kix_igitig4ztshe-4 0}.lst-kix_igitig4ztshe-7>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-7,lower-latin) ". "}.lst-kix_igitig4ztshe-8>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-8,lower-roman) ". "}.lst-kix_8aentbnft-8>li{counter-increment:lst-ctn-kix_8aentbnft-8}ol.lst-kix_igitig4ztshe-7.start{counter-reset:lst-ctn-kix_igitig4ztshe-7 0}.lst-kix_igitig4ztshe-0>li{counter-increment:lst-ctn-kix_igitig4ztshe-0}.lst-kix_igitig4ztshe-3>li{counter-increment:lst-ctn-kix_igitig4ztshe-3}.lst-kix_igitig4ztshe-6>li{counter-increment:lst-ctn-kix_igitig4ztshe-6}ol.lst-kix_igitig4ztshe-0{list-style-type:none}ol.lst-kix_igitig4ztshe-0.start{counter-reset:lst-ctn-kix_igitig4ztshe-0 0}ol.lst-kix_igitig4ztshe-1{list-style-type:none}.lst-kix_8aentbnft-6>li{counter-increment:lst-ctn-kix_8aentbnft-6}ol.lst-kix_igitig4ztshe-2{list-style-type:none}ol.lst-kix_igitig4ztshe-3{list-style-type:none}ol.lst-kix_igitig4ztshe-4{list-style-type:none}ol.lst-kix_igitig4ztshe-5{list-style-type:none}ol.lst-kix_igitig4ztshe-6{list-style-type:none}ol.lst-kix_igitig4ztshe-7{list-style-type:none}ol.lst-kix_igitig4ztshe-8{list-style-type:none}.lst-kix_igitig4ztshe-6>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-6,decimal) ". "}.lst-kix_igitig4ztshe-5>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-5,lower-roman) ". "}ol.lst-kix_igitig4ztshe-3.start{counter-reset:lst-ctn-kix_igitig4ztshe-3 0}.lst-kix_igitig4ztshe-3>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-3,decimal) ". "}.lst-kix_igitig4ztshe-4>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-4,lower-latin) ". "}.lst-kix_igitig4ztshe-1>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-1,lower-latin) ". "}.lst-kix_8aentbnft-3>li{counter-increment:lst-ctn-kix_8aentbnft-3}.lst-kix_igitig4ztshe-2>li:before{content:"" counter(lst-ctn-kix_igitig4ztshe-2,lower-roman) ". "}.lst-kix_8aentbnft-0>li{counter-increment:lst-ctn-kix_8aentbnft-0}ol.lst-kix_igitig4ztshe-6.start{counter-reset:lst-ctn-kix_igitig4ztshe-6 0}.lst-kix_8aentbnft-8>li:before{content:"" counter(lst-ctn-kix_8aentbnft-8,lower-roman) ". "}.lst-kix_igitig4ztshe-7>li{counter-increment:lst-ctn-kix_igitig4ztshe-7}.lst-kix_8aentbnft-6>li:before{content:"" counter(lst-ctn-kix_8aentbnft-6,decimal) ". "}.lst-kix_igitig4ztshe-1>li{counter-increment:lst-ctn-kix_igitig4ztshe-1}.lst-kix_8aentbnft-7>li:before{content:"" counter(lst-ctn-kix_8aentbnft-7,lower-latin) ". "}.lst-kix_p9bdhtkfxbqz-8>li:before{content:"\0025a0  "}ol.lst-kix_8aentbnft-8.start{counter-reset:lst-ctn-kix_8aentbnft-8 0}ol.lst-kix_igitig4ztshe-2.start{counter-reset:lst-ctn-kix_igitig4ztshe-2 0}.lst-kix_8aentbnft-5>li{counter-increment:lst-ctn-kix_8aentbnft-5}.lst-kix_p9bdhtkfxbqz-5>li:before{content:"\0025a0  "}.lst-kix_p9bdhtkfxbqz-7>li:before{content:"\0025cb  "}ol.lst-kix_8aentbnft-0.start{counter-reset:lst-ctn-kix_8aentbnft-0 0}ol.lst-kix_8aentbnft-5.start{counter-reset:lst-ctn-kix_8aentbnft-5 0}.lst-kix_p9bdhtkfxbqz-6>li:before{content:"\0025cf  "}ol.lst-kix_8aentbnft-1{list-style-type:none}ol.lst-kix_8aentbnft-2{list-style-type:none}ol.lst-kix_8aentbnft-0{list-style-type:none}.lst-kix_p9bdhtkfxbqz-1>li:before{content:"\0025cb  "}.lst-kix_p9bdhtkfxbqz-3>li:before{content:"\0025cf  "}ol.lst-kix_8aentbnft-5{list-style-type:none}ol.lst-kix_8aentbnft-6{list-style-type:none}ol.lst-kix_8aentbnft-3{list-style-type:none}ol.lst-kix_8aentbnft-4{list-style-type:none}.lst-kix_p9bdhtkfxbqz-0>li:before{content:"\0025cf  "}.lst-kix_p9bdhtkfxbqz-4>li:before{content:"\0025cb  "}.lst-kix_8aentbnft-0>li:before{content:"" counter(lst-ctn-kix_8aentbnft-0,decimal) ". "}ol.lst-kix_8aentbnft-7.start{counter-reset:lst-ctn-kix_8aentbnft-7 0}.lst-kix_p9bdhtkfxbqz-2>li:before{content:"\0025a0  "}ol.lst-kix_igitig4ztshe-5.start{counter-reset:lst-ctn-kix_igitig4ztshe-5 0}.lst-kix_8aentbnft-4>li:before{content:"" counter(lst-ctn-kix_8aentbnft-4,lower-latin) ". "}.lst-kix_8aentbnft-4>li{counter-increment:lst-ctn-kix_8aentbnft-4}ul.lst-kix_p9bdhtkfxbqz-8{list-style-type:none}.lst-kix_8aentbnft-7>li{counter-increment:lst-ctn-kix_8aentbnft-7}ul.lst-kix_p9bdhtkfxbqz-5{list-style-type:none}ul.lst-kix_p9bdhtkfxbqz-4{list-style-type:none}.lst-kix_8aentbnft-1>li:before{content:"" counter(lst-ctn-kix_8aentbnft-1,lower-latin) ". "}.lst-kix_8aentbnft-5>li:before{content:"" counter(lst-ctn-kix_8aentbnft-5,lower-roman) ". "}ul.lst-kix_p9bdhtkfxbqz-7{list-style-type:none}.lst-kix_igitig4ztshe-2>li{counter-increment:lst-ctn-kix_igitig4ztshe-2}ul.lst-kix_p9bdhtkfxbqz-6{list-style-type:none}ol.lst-kix_8aentbnft-1.start{counter-reset:lst-ctn-kix_8aentbnft-1 0}ol.lst-kix_8aentbnft-4.start{counter-reset:lst-ctn-kix_8aentbnft-4 0}ul.lst-kix_p9bdhtkfxbqz-1{list-style-type:none}ul.lst-kix_p9bdhtkfxbqz-0{list-style-type:none}ol.lst-kix_igitig4ztshe-8.start{counter-reset:lst-ctn-kix_igitig4ztshe-8 0}ol.lst-kix_8aentbnft-7{list-style-type:none}ul.lst-kix_p9bdhtkfxbqz-3{list-style-type:none}ol.lst-kix_8aentbnft-8{list-style-type:none}ul.lst-kix_p9bdhtkfxbqz-2{list-style-type:none}.lst-kix_8aentbnft-2>li:before{content:"" counter(lst-ctn-kix_8aentbnft-2,lower-roman) ". "}.lst-kix_igitig4ztshe-5>li{counter-increment:lst-ctn-kix_igitig4ztshe-5}.lst-kix_igitig4ztshe-8>li{counter-increment:lst-ctn-kix_igitig4ztshe-8}.lst-kix_8aentbnft-3>li:before{content:"" counter(lst-ctn-kix_8aentbnft-3,decimal) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c1{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c14{padding-top:24pt;padding-bottom:6pt;line-height:1.15;text-align:left}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c19{padding-top:18pt;padding-bottom:4pt;line-height:1.15;text-align:left}.c12{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{padding-top:0pt;padding-bottom:0pt}.c6{font-size:9pt;font-family:"Consolas"}.c2{color:#000099;text-decoration:underline}.c11{color:inherit;text-decoration:inherit}.c7{color:#b7b7b7;font-size:9pt}.c13{padding:0;margin:0}.c5{font-weight:bold}.c10{text-indent:200pt}.c9{font-size:9pt}.c18{text-decoration:underline}.c4{height:11pt}.c0{font-style:italic}.c16{font-size:12pt}.c17{color:#ff0000}.c15{font-size:18pt}.title{padding-top:24pt;color:#000000;font-weight:bold;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:bold;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:bold;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:bold;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:bold;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:bold;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:bold;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style><h1 class="c14" id="h.pisva0bti8dh"><span>Introducing the Journal</span></h1><p class="c3"><span class="c16">During
 the past weeks we have been working on a new feature for systemd, that 
we’d like to introduce to you today. At the same time as it helps us to 
substantially decrease the footprint of a minimal Linux system it brings
 a couple of new concepts and replaces a major component of a classic 
Unix system. Due that it probably deserves a longer introduction. So, 
grab yourself a good cup of swiss hot chocolate, lean back, read and 
enjoy.</span></p><h2 class="c19" id="h.2jozv45379xw"><span>Background: syslog</span></h2><p><span>An
 important component of every Unix system for a long time has been the 
syslog daemon. During our long history multiple implementations have 
been used in the various Linux distributions for this job, but in 
essence they all implemented a very similar logic and used nearly 
identical file formats on disk.</span></p><p><span></span></p><p><span>The
 purpose of a syslog daemon is -- as the name suggests -- system 
logging. It receives relatively free-form log messages from applications
 and services and stores them on disk. Usually, the only meta data 
attached to these messages are a facility and a priority value, a 
timestamp, a process tag and a PID. These properties are passed in from 
the client, not verified and usually stored away as-is. Most of these 
fields are optional, and the precise syntax is varying wildly in the 
various implementations. An internet RFC eventually tried to formalize 
and improve the message format a bit, however the most important 
implementations (such as glibc’s syslog() call) make little use of these
 improvements.</span></p><p><span></span></p><p class="c3"><span>The 
fact that syslog enforces very little format of the log messages makes 
it both very versatile and powerful, but at the same time is also one of
 its biggest drawbacks. Since no structured format is defined, parsing 
and processing of log messages systematically is messy: the context 
information the generator of the messages knew is lost during the 
transformation into terse, lossy human language, and most log analyzers 
then try to parse the human language again in an attempt to reconstruct 
the context.</span></p><p><span></span></p><p><span>Syslog has been 
around for ~30 years, due to its simplicity and ubiquitousness it is an 
invaluable tool for administrators. However, the number of limitations 
are substantial, and over time they have started to be serious problems:</span></p><p><span></span></p><ol class="c13 lst-kix_igitig4ztshe-0 start" start="1"><li class="c1"><span>The
 message data is generally not authenticated, every local process can 
claim to be Apache under PID 4711, and syslog will believe that and 
store it on disk.</span></li><li class="c1"><span>The data logged is 
very free-form. Automated log-analyzers need to parse human language 
strings to a) identify message types, and b) parse parameters from them.
 This results in regex horrors, and a steady need to play catch-up with 
upstream developers who might tweak the human language log strings in 
new versions of their software. Effectively, in a away, in order not to 
break user-applied regular expressions all log messages become ABI of 
the software generating them, which is usually not intended by the 
developer.</span></li><li class="c1"><span>The timestamps generally do not carry timezone information, even though some newer specifications define support for it.</span></li><li class="c1"><span>Syslog
 is only one of many log systems on local machines. Separate logs are 
kept for utmp/wtmp, lastlog, audit, kernel logs, firmware logs, and a 
multitude of application-specific log formats. This is not only 
unnecessarily complex, but also hides the relation between the log 
entries in the various subsystems.</span></li><li class="c1"><span>Reading
 log files is simple but very inefficient. Many key log operations have a
 complexity of O(n). Indexing is generally not available.</span></li><li class="c1"><span>The
 syslog network protocol is very simple, but also very limited. Since it
 generally supports only a push transfer model, and does not employ 
store-and-forward, problems such as Thundering Herd or packet loss 
severely hamper its use.</span></li><li class="c1"><span>Log files are easily manipulable by attackers, providing easy ways to hide attack information from the administrator</span></li><li class="c1"><span>Access
 control is non-existent. Unless manually scripted by the administrator a
 user either gets full access to the log files, or no access at all.</span></li><li class="c1"><span>The
 meta data stored for log entries is limited, and lacking key bits of 
information, such as service name, audit session or monotonic 
timestamps.</span></li><li class="c1"><span>Automatic rotation of log 
files is available, but less than ideal in most implementations: instead
 of watching disk usage continuously to enforce disk usage limits 
rotation is only attempted in fixed time intervals, thus leaving the 
door open to many DoS attacks.</span></li><li class="c1"><span>Rate 
limiting is available in some implementations, however, generally does 
not take the disk usage or service assignment into account, which is 
highly advisable.</span></li><li class="c1"><span>Compression in the log
 structure on disk is generally available but usually only as effect of 
rotation and has a negative effect on the already bad complexity 
behaviour of many key log operations.</span></li><li class="c1"><span>Classic
 Syslog traditionally is not useful to handle early boot or late 
shutdown logging, even though recent improvements (for example in 
systemd) made this work.</span></li><li class="c1"><span>Binary data cannot be logged, which in some cases is essential (Examples: ATA SMART blobs or SCSI sense data, firmware dumps)</span></li></ol><p class="c3 c4"><span></span></p><p class="c3"><span>Many
 of these issues have become very visible in the recent past. For 
example, intrusion involved in log file manipulation which can usually 
only detected by chance. In addition, due to the limitations of syslog, 
at this point in time users frequently have to rely on closed source 
components to make sense of the gathered logging data, and make access 
to it efficient.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Logging
 is a crucial part of service management. On Unix, most running services
 connect to syslog to write log messages. In systemd, we built logging 
into the very core of service management: since Fedora 16 all services 
started are automatically connected to syslog with their standard output
 and error output. Regardless whether a service is started at early boot
 or during normal operation, its output ends up in the system logs. 
Logging is hence something so central, that it requires configuration to
 avoid it, and is turned from opt-in to opt-out. The net effect is a 
much more transparent, debuggable and auditable system. Transparency is 
no longer just an option for the knowledgeable, but the default.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>During
 the development of systemd the limitations of syslog became more and 
more apparent to us. For example: one very important feature we want to 
add to ease the administrator’s work is showing the last 10 lines (or 
so) of log output of a service next to the general service information 
shown by “systemctl status foo.service”. Implementing this correctly for
 classic syslog is prohibitively inefficient, unreliable and insecure: a
 linear search through all log files (which might involve decompressing 
them on-the-fly) is required, and the data stored might be manipulated, 
and cannot easily (and without races) be mapped to the systemd service 
name and runtime.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>To
 reduce all this to a few words: traditional syslog, after its long 
history of ~30 years has grown into a very powerful tool which suffers 
by a number of severe limitations. </span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Now, what can we do to improve the situation?</span></p><h2 id="h.qrkg5b24styt"><span>The Journal</span></h2><p class="c3"><span>You
 probably already guessed it from the explanations in the section above:
 What we have been working on is a new solution for the logging problem,
 fixing the issues pointed out above and adding a couple of new features
 on top: the </span><span class="c0">Journal</span><span>.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Of course, when designing a new core component of the OS like this, a few design goals should be very clear:</span></p><ol class="c13 lst-kix_8aentbnft-0 start" start="1"><li class="c1"><span class="c0">Simplicity: </span><span>little code with few dependencies and minimal waste through abstraction.</span></li><li class="c1"><span class="c0">Zero Maintenance:</span><span>&nbsp;logging
 is crucial functionality to debug and monitor systems, as such it 
should not be a problem source of its own, and work as well as it can 
even in dire circumstances. For example, that means the system needs to 
react gracefully to problems such as limited disk space or /var not 
being available, and avoid triggering disk space problems on its own 
(e.g. by implementing journal file rotation right in the daemon at the 
time a journal file is extended). </span></li><li class="c1"><span class="c0">Robustness: </span><span>data
 files generated by the journal should be directly accessible to 
administrators and be useful when copied to different hosts with tools 
like “scp” or “rsync”. Incomplete copies should be processed gracefully.
 Journal file browsing clients should work without the journal daemon 
being around.</span></li><li class="c1"><span class="c0">Portable: </span><span>journal
 files should be usable across the full range of Linux systems, 
regardless which CPU or endianess is used. Journal files generated on an
 embedded ARM system should be viewable on an x86 desktop, as if it had 
been generated locally.</span></li><li class="c1"><span class="c0">Performance:</span><span>&nbsp;journal
 operations for appending and browsing should be fast in terms of 
complexity. O(log n) or better is highly advisable, in order to provide 
for organization-wide log monitoring with good performance</span></li><li class="c1"><span class="c0">Integration</span><span>:
 the journal should be closely integrated with the rest of the system, 
so that logging is so basic for a service, that it would need to opt-out
 of it in order to avoid it. Logging is a core responsibility for a 
service manager, and it should be integrated with it reflecting that.</span></li><li class="c1"><span class="c0">Minimal Footprint:</span><span>&nbsp;journal
 data files should be small in disk size, especially in the light that 
the amount of data generated might be substantially bigger than on 
classic syslog.</span></li><li class="c1"><span class="c0">General Purpose Event Storage: </span><span>the journal should be useful to store any kind of journal entry, regardless of its format, its meta data or size.</span></li><li class="c1"><span class="c0">Unification: </span><span>the
 numerous different logging technologies should be unified so that all 
loggable events end up in the same data store, so that global context of
 the journal entries is stored and available later. e.g. a firmware 
entry is often followed by a kernel entry, and ultimately a userspace 
entry. It is key that the relation between the three is not lost when 
stored on disk.</span></li><li class="c1"><span class="c0">Base for Higher Level Tools</span><span>:
 the journal should provide a generally useful API which can be used by 
health monitors, recovery tools, crash report generators and other 
higher level tools to access the logged journal data.</span></li><li class="c1"><span class="c0">Scalability</span><span>:
 the same way as Linux scales from embedded machines to super computers 
and clusters, the journal should scale, too. Logging is key when 
developing embedded devices, and also essential at the other end of the 
spectrum, for maintaining clusters. The journal needs to focus on 
generalizing the common use patterns while catering for the specific 
differences, and staying minimal in footprint.</span></li><li class="c1"><span class="c0">Universality</span><span>:
 as a basic building block of the OS the journal should be universal 
enough and extensible to cater for application-specific needs. The 
format needs to be extensible, and APIs need to be available.</span></li><li class="c1"><span class="c0">Clustering &amp; Network: </span><span>Today
 computers seldom work in isolation. It is crucial that logging caters 
for that and journal files and utilities are from the ground on 
developed to support big multi-host installations.</span></li><li class="c1"><span class="c0">Security: </span><span>Journal files should be authenticated to make undetected manipulation impossible.</span></li></ol><p class="c3 c4"><span></span></p><p class="c3"><span>So much about the design goals, h</span><span>ere’s an high-level technical overview of what we came up with to implement all this and how the new system works:</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Inspired by udev events, </span><span class="c0">journal</span><span>&nbsp;entries
 resemble environment blocks. A number of key/value fields, separated by
 line breaks, with uppercase variable names. In comparison to udev 
device events and real environment blocks there’s one major difference: 
while the focus is definitely on ASCII formatted strings, binary blobs 
as values are also supported -- something which may be used to attach 
binary meta data such as ATA SMART health data, SCSI sense data, 
coredumps or firmware dumps. The code generating a journal entry can 
attach as many fields to an entry as he likes, which can be well-known 
ones, or service/subsystem/driver specific ones.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Applications
 and services may generate entries in the journal by passing entry 
fields to systemd’s journald service. This service will augment the 
entry with a number of meta fields. The values of these trusted fields 
are determined by the journal service itself and cannot be faked by the 
client side. In case hardware and kernel devices are involved, the 
journal service will augment the log entry with the currently available 
device information from the udev database, which stores all known device
 names and symlinks, and other associated device data in the journal 
entry.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>The
 fields the journal daemon adds are prefixed with an underscore (“_”) as
 an indication that this field is trusted and not supplied by a 
potentially rogue client. Applications themselves cannot pass field 
names starting with an underscore. Here’s an example how an entry sent 
from a client after augmentation might look:</span></p><p class="c4 c10"><span class="c6"></span></p><p><span class="c6">_SERVICE=systemd-logind.service</span></p><p><span class="c6">MESSAGE=User harald logged in</span></p><p><span class="c6">MESSAGE_ID=422bc3d271414bc8bc9570f222f24a9</span></p><p><span class="c6">_EXE=/lib/systemd/systemd-logind</span></p><p><span class="c6">_COMM=systemd-logind</span></p><p><span class="c6">_CMDLINE=/lib/systemd/systemd-logind</span></p><p><span class="c6">_PID=4711</span></p><p><span class="c6">_UID=0</span></p><p><span class="c6">_GID=0</span></p><p><span class="c6">_SYSTEMD_CGROUP=/system/systemd-logind.service</span></p><p><span class="c6">_CGROUPS=cpu:/system/systemd-logind.service</span></p><p><span class="c6">PRIORITY=6</span></p><p><span class="c6">_BOOT_ID=422bc3d271414bc8bc95870f222f24a9</span></p><p><span class="c6">_MACHINE_ID=c686f3b205dd48e0b43ceb6eda479721</span></p><p><span class="c6">_HOSTNAME=waldi</span></p><p class="c3"><span class="c6">LOGIN_USER=500</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>This
 example entry is generated by systemd's logind daemon when a user 
“harald” logs in. As you can see the automatically added data is quite 
comprehensive and includes a number of important process execution 
parameters. For a longer explanation on the various well-known fields 
defined see:</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c2"><a class="c11" href="https://www.google.com/url?q=https://docs.google.com/document/pub?id%3D1MqQpm-ey8yVDPY8QVL155pvivay3Ut09dKxeVyNCrp8&amp;sa=D&amp;ust=1461841349162000&amp;usg=AFQjCNFAxShL-p221ObCCOZm01LfEWvzfA">https://docs.google.com/document/pub?id=1MqQpm-ey8yVDPY8QVL155pvivay3Ut09dKxeVyNCrp8</a></span></p><p class="c3 c4"><span></span></p><p class="c3"><span>The
 native journal file format is inspired by classic log files as well as 
git repositories. It is designed in a way that log data is only attached
 at the end (in order to ensure robustness and atomicity with 
mmap()-based access), with some meta data changes in the header to 
reference the new additions. The fields, an entry consists off, are 
stored as individual objects in the journal file, which are then 
referenced by all entries, which need them. This saves substantial disk 
space since journal entries are usually highly repetitive (think: every 
local message will include the same _HOSTNAME= and _MACHINE_ID= field). 
Data fields are compressed in order to save disk space. The net effect 
is that even though substantially more meta data is logged by the 
journal than by classic syslog the disk footprint does not immediately 
reflect that.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>The
 on disk format uses exclusively 64bit LE (little endian) offsets, in 
order to simplify things and ensure we can store blob data of 
substantial sizes. No synchronization between log browser tools and 
journald is necessary, clients which want to browse the journal files 
can simply mmap() the journal files and use file change notifications 
for information about updates.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>A
 client library to allow access to the journal files is available, which
 enables indexed access to entries via any field, and with random access
 via monotonic or wallclock timestamps. The client library automatically
 coalesces multiple journal files so that they appear as a single 
unified stream of journal entries. This is used to hide whether journal 
files are archived (i.e. “rotated”) or belong to multiple users. The 
transparent merging of journal files in the browsing interface is fully 
dynamic: as new journal files are created or old ones deleted the 
&nbsp;browser view is automatically updated. In fact, journal browsing 
is intended to be live, to enable real-time monitoring of journal 
sources.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c2"><a class="c11" href="https://www.google.com/url?q=http://cgit.freedesktop.org/systemd/tree/src/journal/sd-journal.h?h%3Djournal&amp;sa=D&amp;ust=1461841349164000&amp;usg=AFQjCNHO3kzsnJxWWxlexVFXMmPtJu5oiA">http://cgit.freedesktop.org/systemd/tree/src/journal/sd-journal.h?h=journal</a></span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Messages
 from unprivileged login users are split off into individual journal 
files, one per user. Using POSIX ACLs for controlling read access, it is
 ensured that users can access their own journal files. The journal 
entries generated by system services are by default not accessible by 
normal users, unless they are a member of a special Unix group. Note 
that the separation of files happens to accommodate for proper access 
control, but the global contexts of log entries is not lost, due to the 
client side coalescing of journal files, and by enforcing a single 
needle eye all messages are passed through to guarantee global ordering 
by automatically assigned sequence numbers. In effect this means that 
access control is guaranteed without compromise regarding the context of
 user journal entries.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>One
 of the core ideas of the journal is to unify the various logging 
technologies we currently have. As such it should be useful as 
replacement for wtmp, early boot loggers and even the audit logging 
backend. Data can be generated from a variety of sources: kernel 
messages generated with printk(), userspace messages generated with 
syslog(3), userspace entries using the native API, coredumps via 
/proc/proc/sys/kernel/core_pattern and more. Later on we hope to hook up
 firmware messages (UEFI logs) and extend kernel based logging to 
support in-kernel structured logging. Since all fields are implicitly 
indexed in the journal data structure it is a relatively cheap operation
 to extract user data like from wtmp from the journal. Early-boot and 
runtime logging are unified. As long as /var is not available, all 
journal entries are automatically stored on /run, and then flushed to 
/var as soon as it is available. This means that ultimately all messages
 generated by the system, regardless whether by the firmware during 
POST, during kernel initialisation, during early boot or at runtime, end
 up in the same indexed journal files.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>In
 order to make entries recognisable to client utilities, journal entries
 may optionally carry a 128bit identifier in MESSAGE_ID=, set by the 
service generating the message. This ID shall be a randomly generated ID
 by the developer at development time. For example, there’s one ID for 
“User logged out” and another one for “User logged in”. All entries for 
these events will carry the respective 128bit ID thus making them easily
 recognisable, and implicitly indexed by them. It is a good idea to use 
IDs for this which are compatible with RFC4122 UUID of type 4, however 
this is not strictly required and not enforced. This is designed to be 
compatible with other logging systems which use UUIDs to identify 
message types, such as the UEFI firmware logs. Consider these 128bit IDs
 global error codes, that due to their randomized nature need no central
 standardization entity that assigns numeric IDs to specific message 
types. Assigning message IDs is entirely optional, and we expect that 
only a minority of journal entries will carry them, i.e. only those 
which need to be recognisable by userspace. If a developer needs a new 
128bit ID to assign to a new message type he introduced, all he needs to
 do is run “cat /proc/sys/kernel/random/uuid” which returns a new UUID 
on each invocation. The 128bit IDs can also be used to implement 
localized message UIs, which look up messages in a language catalog and 
present the translated message to the user, entirely in the UI tool.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>All
 entries are implicitly timestamped with the realtime (i.e. wallclock) 
and monotonic clock. To make the monotonic timestamps useful all 
messages also carry the boot ID of the running Linux kernel (i.e. 
/proc/sys/kernel/random/boot_id). The accuracy is 1usec, and the 
wallclock is stored in usec since the epoch UTC in order to avoid the 
timezone problems syslog is suffering by.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Journal
 files can be rotated, deleted, copied to other machines, merged, or 
otherwise manipulated. In order to ensure that applications, 
synchronization tools and network services can reliably identify entries
 all journal entries can be identified by a </span><span class="c0">cursor </span><span>string.
 Such a string identifies a specific message and stays stable even when 
an entry is lost or not available, and then can be used to locate the 
next closest entry.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>journald
 automatically rotates journal files if they grow above certain limits. 
This is built right into the disk space allocation logic, in order to 
avoid vulnerability windows due to purely time-based rotation. Rotation 
not only takes a maximum disk usage limit into account, but also 
monitors general disk usage levels in order to ensure that a certain 
amount of space is always kept free on disk.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Entries
 sent by clients are subject to implicit rate limiting, to avoid that 
rogue clients can flush relevant data out of the journal, by flooding it
 with is own data. The rate is adjusted by the amount of available disk 
space, so that higher message rates are allowed when disk space is 
generous and lower rates enforced when disk space is scarce</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>In
 the initial version journald’s network support will be very simple: to 
share journal files across the network, simply copy them to a central 
host with a tool like scp, rsync or via NFS. The journal browser client 
tool will then transparently merge these files, interleaving them as 
necessary. In a later version we plan to extend the journal minimally to
 support live remote logging, in both PUSH and PULL modes always using a
 local journal as buffer for a store-and-forward logic. Regardless which
 mode of transportation is used, the underlying journal format is 
designed to be scalable to large numbers of hosts and all entries are 
identified by both the machine ID and the host name. The goal is to 
implement an efficient journal monitoring tool that can browse journals 
from a multitude of hosts transparently and live, while leaving to the 
administrator the choice of transport so that he can adjust it to his 
own needs, i.e. whether live functionality is more important than 
avoiding the thundering herd, and other considerations.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>The
 Internet is a dangerous place. Break-ins on high-profile web sites have
 become very common. After a successful break-in the attacker usually 
attempts to hide his traces by editing the log files. Such manipulations
 are hard to detect with classic syslog: since the files are plain text 
files no cryptographic authentication is done, and changes are not 
tracked. Inspired by git, in the journal all entries are 
cryptographically hashed along with the hash of the previous entry in 
the file. This results in a chain of entries, where each entry 
authenticates all previous ones. If the top-most hash is regularly saved
 to a secure write-once location, the full chain is authenticated by it.
 Manipulations by the attacker can hence easily be detected.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>As
 mentioned logging is an essential part of service management. That not 
only refers to the fact that the service’s own log output needs to be 
channeled to the journal, but also that journal entries are generated 
for external service events, for example, each time when a service 
starts, fails, stops or crashes.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>The journal daemon </span><span class="c0">journald</span><span>&nbsp;replaces
 the two mini daemons systemd already ships that are related to logging 
(systemd-kmsg-syslogd and systemd-stdout-syslog-bridge) right from the 
beginning. In the long run we hope to replace the traditional syslog 
daemons on many installations, but not conflict with them. The net 
footprint of a Linux system should shrink, due the reduction of services
 run (1 in place of 3), and because journald is actually much less code 
than a full-blown syslog daemon.</span></p><h2 id="h.550lcmtbk9z8"><span>Current Status</span></h2><p class="c3"><span>At
 this point in time, the core functionality and all non-trivial 
algorithms are implemented and available in the “journal” branch in 
systemd git. The code however is not complete, and missing a number of 
features pointed out above.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>This
 blog story we put together to clear up a few misconceptions of our 
plans, choices and reasons that have been uttered in the community.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>It
 is our intention to put an initial implementation of this into Fedora 
17, but hook up only very few selected components directly with it in 
the first iteration. rsyslog will run side-by-side with it, and the user
 should notice very little of journald, except that “systemctl status” 
will start to show recent log output for all services. Unless of course 
he plays around with our new client tools, like “journalctl” which may 
be used to search the (indexed) journal.</span></p><h2 id="h.iuu9hkt2hqtm"><span>Frequently Asked Questions</span></h2><p><span>We
 have been discussing the design above with a number of people from 
various backgrounds in the past weeks, collecting ideas, suggestions and
 criticism. A couple of points were raised very vocally, and repeatedly.
 Here’s a list of them with our answers:</span></p><p><span></span></p><p class="c3"><span class="c5">The journal is cool, but systemd is an abomination, can I use the journald without systemd?</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>No,
 you can’t. Logging is a core part of service management. The journal is
 tightly integrated with the rest of systemd to ensure that everything 
in the system can be monitored, introspected and debugged. The generated
 journal entries are queried from various components in systemd. In 
effect systemd and journald are so tightly coupled that separating them 
would make little sense. That said, it’s Free Software, so you can do 
with the code whatever suits you. Finally, you are actually wrong in 
believing that systemd was an abomination.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c5">Does running the journal break rsyslog/syslog-ng?</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>No,
 it doesn’t. You may run rsyslog or syslog-ng side-by-side with 
journald, and syslog messages will end up in both rsyslog/syslog-ng and 
the journal. However, the journal will store a lot of meta data along 
with the syslog messages that plain syslog won’t.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c5">My application needs traditional text log files on disk, can I configure journald to generate those?</span></p><p><span></span></p><p><span>No,
 you can’t. If you need this, just run the journal side-by-side with a 
traditional syslog implementation like rsyslog which can generate this 
file for you.</span></p><p><span></span></p><p><span class="c5">Why doesn’t the journal generate traditional log files?</span></p><p><span class="c5"></span></p><p><span>Well,
 for starters, traditional log files are not indexed, and many key 
operations very slow with a complexity of O(n). The native journal file 
format allows O(log(n)) complexity or better for all important 
operations. For more reasons, refer to the sections above.</span></p><p><span></span></p><p><span class="c5">Can I connect a remote RFC compliant syslog protocol message generator to the journal?</span></p><p><span class="c5"></span></p><p><span>At
 this point in time, no, you can’t. And it is unlikely that journald 
will ever support this out-of-the-box. However, it shouldn’t be too 
difficult to write a converter or gateway tool to make this work.</span></p><p><span></span></p><p><span class="c5">I am using systemd on an embedded system and am not interested in persistent logging, can I opt out of the journal?</span></p><p><span></span></p><p><span>No
 you can’t really. However, what you can do is tell systemd that you 
don’t want persistent logging, by removing (or not creating in the first
 place) the /var/log/journal directory, in which case journald will log 
only to /run/log/journal (which it does in any case during early boot). 
/run is volatile and lost on reboots, in contrast to /var. On top of 
that you can configure the maximum disk space the journal may consume to
 a low value.</span></p><p><span></span></p><p><span class="c5">UUIDs are broken, everybody knows that. Why are you using UUIDs to identify messages?</span></p><p><span></span></p><p class="c3"><span>Well,
 it is true that the UUID specification is baroque and needlessly 
complex. Due to that we recommend sticking to UUID Type 4 and ignoring 
the rest of RFC 4122. UUIDs actually have a long successful history on 
Linux. For example, all distributions by default mount file systems 
exclusively by their file system UUIDs.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span class="c5">But
 meh, UUIDs never worked! i.e. MAC addresses are duplicated and all my 
USB devices have the same one! Why do you insist on using them?</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Well,
 we are using them all the time, in file systems for example, as already
 mentioned above, and they do their job very nicely there and always 
have. Hardware carries serial numbers that many vendors initialize to 
1-2-3-4-5 or similar, but that has very little to do with the general 
idea of UUIDs. Device serial numbers aren’t UUIDs. Don’t mix them up!</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>In
 addition, we are not insisting on them. As mentioned above they are 
fully optional, and should only be assigned to those messages that shall
 be recognisable later on.</span></p><p><span></span></p><p class="c3"><span class="c5">But
 if I introduce a UUID for a message type in my code and somebody uses 
this code as a template for some new work then the journal breaks.</span></p><p class="c3 c4"><span class="c5"></span></p><p><span>No,
 this is wrong. Why? Simply because the same 128bit ID should be 
assigned to the same error condition/entry type, regardless from which 
source it comes. e.g. the 128bit ID that is used to identify “Sector bad
 on block device” should be the same regardless which device generates 
the message, or which driver. If userspace software needs to distinguish
 journal entries from different services, drivers or devices, it should 
use additional journal matches on the service/device/driver fields.</span></p><p><span></span></p><p><span>Or
 in other words, what you are pointing out is actually a good thing. We 
specifically encourage people to reuse message IDs, which describe the 
same thing, in their software, instead of inventing new ones.</span></p><p><span></span></p><p><span class="c5">But still, the printf()/printk() format strings of the messages would be much better for identifying message types!</span></p><p><span></span></p><p><span>That’s
 actually not really the case. Ultimately format strings are just human 
language templates. And human language is fragile for message type 
identification: every corrected spelling mistake would alter the message
 type, and cause journal clients to misidentify messages. Every time a 
journal message is extended, reworded, rewritten an ABI break takes 
places. Or to turn this around: by using message format strings as 
identifiers every message of the kernel becomes ABI, and turning human 
language into ABI is fatal. Effectively, little is gained over the 
classic regex log matching at a very steep price of making all log 
messages ABI. OTOH messages IDs can stay unaltered when their human 
languages strings are altered, thus neatly separating ABI from the human
 language. </span></p><p><span></span></p><p><span class="c5">You guys really don’t get it! You should totally use the source code file name and location as identifier for messages!</span></p><p><span></span></p><p><span>This
 is not really feasible, since it would turn the source code location 
into ABI: every time the developer adds a new line of code at the top of
 his .c file all message IDs would change. This would be major problem.</span></p><p><span></span></p><p><span class="c5">Who
 would organize and manage the UUID namespace and generate UUIDs? 
Seriously, we don’t need more bureaucracy people will only ignore!</span></p><p><span></span></p><p><span>The
 nice thing about 128bit random IDs is that their namespace does not 
need to be managed. Everybody can just pull a random UUID out of 
/proc/sys/kernel/random/uuid, and it is his. Developers can generate as 
many UUIDs as they need without having to ask any central entity. UUIDs 
allow us to have a common namespace without any bureaucracy.</span></p><p><span></span></p><p><span class="c5">But
 come on, seriously! UUIDS? From which planet are you!? Everybody knows 
that an agency like LANANA would be ideal for assigning globally unique 
message type IDs to applications!</span></p><p><span></span></p><p><span>Linux
 is not an island. It’s highly desirable that message IDs used by other 
infrastructure seamlessly integrates with what we do in the Journal. 
Hence we pick something that makes sense and is already used elsewhere. 
Also, UUIDs are essentially little more than a global namespace for 
unique identifiers that needs no central organization. Why have the 
bureaucracy of a central understaffed registrar if you don’t have to?</span></p><p><span></span></p><p><span class="c5">Nah, you should use reverse domain name notation to identify message types, like Java!</span></p><p><span></span></p><p><span>Comparing
 strings is substantially more complex that comparing fixed size IDs. 
Also, let’s face it, this wouldn’t solve the namespacing issue anyway, 
since 90% of all message types would probably be in the same namespaces:
 org.freedesktop resp. org.kernel.</span></p><p><span></span></p><p><span class="c5">But ASN.1 OIDs would make great message type identifiers!</span></p><p><span class="c5"></span></p><p><span>Dude, seriously?</span></p><p><span></span></p><p><span class="c5">Now I have an even better idea, what about using URLs as message type IDs?</span></p><p><span></span></p><p><span>Well, they offer little advantage over reverse domain name notation, don’t they?</span></p><p><span></span></p><p><span class="c5">But guys, really. If you always generate a UUID on each entry that is generated my entire entropy pool will always be drained!</span></p><p><span class="c5"></span></p><p><span>Read
 the blog story again, as you apparently didn’t read it very carefully. 
The 128bit message type IDs are assigned by the developer when he needs 
one to identify a specific message type at the time of developing, not 
at runtime. Most projects will probably never generate more than 30 of 
these during their entire development time, and the entropy for that 
should be trivially available on developer machines, even 10 years old.</span></p><p><span></span></p><p><span class="c5">You
 crazy userspace kids, first you force me to use have 20 cpu cgroups on 
my system, and now you force me to have stinky UUIDs on my system?</span></p><p><span class="c5"></span></p><p><span>Well,
 ignoring the fact that we don’t force you to have 20 cpu cgroups, and 
that you are almost definitely already using UUIDs all the time because 
your file systems are found via UUIDs at boot time -- consider them an 
implementation detail, and if you don’t like them, then you don’t have 
to attach them to your messages. That comes at the price that the 
messages aren’t recognisable though, except via regex matching horrors. 
But hey, maybe that’s what you want? And anyway, we don’t force anybody 
to do anything anyway. </span></p><p><span></span></p><p><span class="c5">So
 you are splitting up journal entries based on the user ID of the user 
sending them. But how do you make sure that the user doesn’t lie about 
who he is?</span></p><p><span></span></p><p><span>Thankfully, the Linux 
kernel supports SCM_CREDENTIALS, which provides us with information 
about the sender of a message he cannot fake.</span></p><p><span></span></p><p><span class="c5">Will the journal file format be standardized? Where can I find an explanation of the on-disk data structures?</span></p><p><span></span></p><p><span>At
 this point we have no intention to standardize the format and we take 
the liberty to alter it as we see fit. We might document the on-disk 
format eventually, but at this point we don’t want any other software to
 read, write or manipulate our journal files directly. The access is 
granted by a shared library and a command line tool. (But then again, 
it’s Free Software, so you can always read the source code!)</span></p><p><span></span></p><p><span class="c5">Why
 do you guys reinvent the wheel, again? Why not just add what you need 
to existing syslog? If you just clean up your log formatting, syslog 
should be fine!</span></p><p><span class="c5"></span></p><p><span>Well, 
sometimes improving an existing solution is the way to go, but when the 
changes necessary are too major a reinvention is a good thing, if it is 
done for the right reasons, and provides good compatibility with 
previous solutions. We believe we are doing it for the right reasons, 
and we try hard to provide greatest possible compatibility.</span></p><p><span></span></p><p><span>And
 no, just fixing the log formatting won’t get you much. Not even the 
most basic requirements like binary blobs or sensible structured 
logging. Let alone stuff like indexing or proper access control.</span></p><p><span></span></p><p><span class="c5">Does the journal obsolete syslog entirely?</span></p><p><span class="c5"></span></p><p class="c3"><span>No,
 first of all, the syslog API syslog(3) is supported as first-class 
interface to write log messages, and continues to be the primary API for
 all simple text logging. However, as soon as meta data (especially 
binary meta data) shall be attached to an entry the native journal API 
should be used instead.</span></p><p class="c3 c4"><span></span></p><p class="c3"><span>Secondly,
 the journal is an entirely new thing. OTOH, Syslog is an industry 
standard (though a pretty weakly defined one, given that its log format 
is barely agreed on), and a widely accepted one, which is implemented in
 numerous operating systems, applications and devices. As such, syslog 
will continue to be important and will be needed on many many 
installations. The journal daemon does not speak the RFC syslog 
protocol, and it is unlikely it ever will. Wherever protocol 
compatibility with syslog is required, a classic syslog implementation 
needs to be used. To ensure this works nicely, we implemented the 
journal so that it can cooperate cleanly with a local syslog daemon and 
messages are forwarded as needed so that syslog continues to work 
exactly as it did without journald in the mix.</span></p><h2 id="h.wrkvgp7hdkk9"><span>And this is where You come in!</span></h2><p class="c8"><span>Before
 putting together this design we spoke to a number of high profile log 
users, including users with more than a hundred thousand active hosts. 
We also spoke to a number of engineers who worked in the area or might 
become major users of the journal. We were particularly interested in 
usage patterns, and scalability issues. However, of course every 
installation has its own needs and requirements. Thus we’d like to ask 
you to contact us in case there’s some important functionality you’d 
need for your specific setup that you currently don’t find covered in 
the design pointed out above. The design above focuses exclusively on 
the lower layers of the logging stack. Specific UIs are out of focus for
 us, for now, thus we’d like to ask you to leave comments about them for
 a later time. Also, it’s not Christmas yet, so we are unlikely to 
fulfil all wishes (please don’t be disappointed!), but it matters to us 
to learn about them, and we can promise that we’ll at least consider 
them! Thank you very much in advance!</span></p><p class="c3 c4"><span class="c17"></span></p><p class="c3 c4"><span class="c17"></span></p><p class="c3"><span class="c7">History:</span></p><p class="c3"><span class="c7">2011-11-18 release</span></p><p class="c3"><span class="c7">2011-11-23 removed</span><span class="c9">&nbsp;</span><span class="c7 c18"><a class="c11" href="https://www.google.com/url?q=http://kernel.org&amp;sa=D&amp;ust=1461841349196000&amp;usg=AFQjCNHcnS6pPuhVco6vAQrhwZWw99UsHw">kernel.org</a></span><span class="c7">&nbsp;log file tampering example</span></p></div><div id="footer"><span>Published by <a target="_blank" title="Learn more about Google Drive" href="https://docs.google.com/">Google Drive</a></span><span class="dash">–</span><a href="https://docs.google.com/abuse?id=1IC9yOXj7j6cdLLxWEBAGRL6wl97tFxgjLUEHIX3MSTs">Report Abuse</a><span class="dash">–</span><span>Updated automatically every 5 minutes</span></div><script type="text/javascript">(function(){if(window.jstiming){window.jstiming.a={};window.jstiming.b=1;var f=function(b,a,d){var c=b.t[a],e=b.t.start;if(c&&(e||d))return c=b.t[a][0],void 0!=d?e=d:e=e[0],Math.round(c-e)},m=function(b,a,d){var c="";window.jstiming.srt&&(c+="&srt="+window.jstiming.srt,delete window.jstiming.srt);window.jstiming.pt&&(c+="&tbsrt="+window.jstiming.pt,delete window.jstiming.pt);try{window.external&&window.external.tran?c+="&tran="+window.external.tran:window.gtbExternal&&window.gtbExternal.tran?c+="&tran="+window.gtbExternal.tran():
window.chrome&&window.chrome.csi&&(c+="&tran="+window.chrome.csi().tran)}catch(t){}var e=window.chrome;if(e&&(e=e.loadTimes)){e().wasFetchedViaSpdy&&(c+="&p=s");if(e().wasNpnNegotiated){var c=c+"&npn=1",g=e().npnNegotiatedProtocol;g&&(c+="&npnv="+(encodeURIComponent||escape)(g))}e().wasAlternateProtocolAvailable&&(c+="&apa=1")}var k=b.t,r=k.start,e=[],g=[],h;for(h in k)if("start"!=h&&0!=h.indexOf("_")){var l=k[h][1];l?k[l]&&g.push(h+"."+f(b,h,k[l][0])):r&&e.push(h+"."+f(b,h))}delete k.start;if(a)for(var n in a)c+=
"&"+n+"="+a[n];(a=d)||(a="https:"==document.location.protocol?"https://csi.gstatic.com/csi":"http://csi.gstatic.com/csi");return[a,"?v=3","&s="+(window.jstiming.sn||"_s")+"&action=",b.name,g.length?"&it="+g.join(","):"",c,"&rt=",e.join(",")].join("")};window.jstiming.getReportUri=m;var p=function(b,a,d){b=m(b,a,d);if(!b)return"";a=new Image;var c=window.jstiming.b++;window.jstiming.a[c]=a;a.onload=a.onerror=function(){window.jstiming&&delete window.jstiming.a[c]};a.src=b;a=null;return b};window.jstiming.report=
function(b,a,d){if("prerender"==document.webkitVisibilityState){var c=!1,e=function(){if(!c){a?a.prerender="1":a={prerender:"1"};var g;"prerender"==document.webkitVisibilityState?g=!1:(p(b,a,d),g=!0);g&&(c=!0,document.removeEventListener("webkitvisibilitychange",e,!1))}};document.addEventListener("webkitvisibilitychange",e,!1);return""}return p(b,a,d)};window.jstiming.reportDone=function(b){if(window.jstiming.b<=(b||1))return!1;for(var a in window.jstiming.a)return!1;return!0};var q=function(b,a,
d,c){return 0<d?(c?b.tick(a,c,d):b.tick(a,"",d),!0):!1};window.jstiming.getNavTiming=function(b){if(window.performance&&window.performance.timing){var a=window.performance.timing;q(b,"_dns",a.domainLookupStart)&&q(b,"dns_",a.domainLookupEnd,"_dns");q(b,"_con",a.connectStart)&&q(b,"con_",a.connectEnd,"_con");q(b,"_req",a.requestStart)&&q(b,"req_",a.responseStart,"_req");q(b,"_rcv",a.responseStart)&&q(b,"rcv_",a.responseEnd,"_rcv");if(q(b,"_ns",a.navigationStart)){q(b,"ntsrt_",a.responseStart,"_ns");
q(b,"nsfs_",a.fetchStart,"_ns");var d=!1;try{d=window.external&&window.external.startE}catch(c){}!d&&window.chrome&&window.chrome.csi&&(d=Math.floor(window.chrome.csi().startE));d&&(q(b,"_se",d),q(b,"sens_",a.navigationStart,"_se"));q(b,"ntplt0_",a.loadEventStart,"_ns");q(b,"ntplt1_",a.loadEventEnd,"_ns")}}}};})()
</script>
<script type="text/javascript">KX_timer.tick('tl'); if (document.location.protocol == 'https:') {window.jstiming.report(KX_timer, undefined , 'https://gg.google.com/csi');} else {window.jstiming.report(KX_timer);}</script><script type="text/javascript">(function() { var k=this;
function l(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}function aa(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}function m(a,b){function c(){}c.prototype=b.prototype;a.s=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.w=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)}};function q(){this.b=this.b;this.a=this.a}q.prototype.b=!1;q.prototype.l=function(){this.b||(this.b=!0,this.g())};q.prototype.g=function(){if(this.a)for(;this.a.length;)this.a.shift()()};function ba(a){a&&"function"==typeof a.l&&a.l()};var r=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},ca=/&/g,da=/</g,ea=/>/g,fa=/"/g,ga=/'/g,ha=/\x00/g,ia=/[\x00&<>"']/;function t(a,b){return a<b?-1:a>b?1:0};var ja=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if("string"==typeof a)return"string"==typeof b&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};function ka(a,b,c){for(var d in a)b.call(c,a[d],d,a)};var v;a:{var w=k.navigator;if(w){var x=w.userAgent;if(x){v=x;break a}}v=""}function y(a){return-1!=v.indexOf(a)};function A(){this.a="";this.b=B}A.prototype.o=!0;A.prototype.m=function(){return this.a};function C(a){return a instanceof A&&a.constructor===A&&a.b===B?a.a:"type_error:SafeUrl"}var la=/^(?:(?:https?|mailto|ftp):|[^&:/?#]*(?:[/?#]|$))/i;function ma(a){if(a instanceof A)return a;a=a.o?a.m():String(a);la.test(a)||(a="about:invalid#zClosurez");return na(a)}var B={};function na(a){var b=new A;b.a=a;return b}na("about:blank");function D(){this.a="";this.b=oa}D.prototype.o=!0;D.prototype.m=function(){return this.a};var oa={};function E(a){var b=new D;b.a=a;return b}E("<!DOCTYPE html>");E("");E("<br>");var pa=y("Opera"),F=y("Trident")||y("MSIE"),qa=y("Edge"),ra=qa||F,G=y("Gecko")&&!(-1!=v.toLowerCase().indexOf("webkit")&&!y("Edge"))&&!(y("Trident")||y("MSIE"))&&!y("Edge"),H=-1!=v.toLowerCase().indexOf("webkit")&&!y("Edge"),sa=y("Macintosh");function ta(){var a=k.document;return a?a.documentMode:void 0}var I;
a:{var J="",K=function(){var a=v;if(G)return/rv\:([^\);]+)(\)|;)/.exec(a);if(qa)return/Edge\/([\d\.]+)/.exec(a);if(F)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(H)return/WebKit\/(\S+)/.exec(a);if(pa)return/(?:Version)[ \/]?(\S+)/.exec(a)}();K&&(J=K?K[1]:"");if(F){var L=ta();if(null!=L&&L>parseFloat(J)){I=String(L);break a}}I=J}var ua=I,va={};
function M(a){var b;if(!(b=va[a])){b=0;for(var c=r(String(ua)).split("."),d=r(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",h=d[f]||"",u=RegExp("(\\d*)(\\D*)","g"),p=RegExp("(\\d*)(\\D*)","g");do{var n=u.exec(g)||["","",""],z=p.exec(h)||["","",""];if(0==n[0].length&&0==z[0].length)break;b=t(0==n[1].length?0:parseInt(n[1],10),0==z[1].length?0:parseInt(z[1],10))||t(0==n[2].length,0==z[2].length)||t(n[2],z[2])}while(0==b)}b=va[a]=0<=b}return b}
var wa=k.document,N=wa&&F?ta()||("CSS1Compat"==wa.compatMode?parseInt(ua,10):5):void 0;!G&&!F||F&&9<=Number(N)||G&&M("1.9.1");F&&M("9");function O(a){O[" "](a);return a}O[" "]=function(){};var xa=!F||9<=Number(N),ya=!F||9<=Number(N),za=F&&!M("9");!H||M("528");G&&M("1.9b")||F&&M("8")||pa&&M("9.5")||H&&M("528");G&&!M("8")||F&&M("9");function P(a,b){this.type=a;this.a=this.target=b;this.f=!1}P.prototype.c=function(){this.f=!0};function Q(a,b){P.call(this,a?a.type:"");this.a=this.target=null;this.g=!1;this.b=null;if(a){this.type=a.type;this.target=a.target||a.srcElement;this.a=b;var c=a.relatedTarget;if(c&&G)try{O(c.nodeName)}catch(d){}this.g=a.ctrlKey;this.b=a;a.defaultPrevented&&this.c()}}m(Q,P);var Aa=[1,4,2];Q.prototype.c=function(){Q.s.c.call(this);var a=this.b;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,za)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var Ba="closure_listenable_"+(1E6*Math.random()|0),Ca=0;function Da(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.j=!!d;this.b=e;this.u=++Ca;this.h=this.i=!1}function Ea(a){a.h=!0;a.listener=null;a.a=null;a.src=null;a.b=null};function Fa(a){this.src=a;this.a={};this.b=0};var R="closure_lm_"+(1E6*Math.random()|0),S={},Ga=0;
function Ha(a,b,c,d,e){if("array"==l(b)){for(var f=0;f<b.length;f++)Ha(a,b[f],c,d,e);return null}c=Ia(c);if(a&&a[Ba])a=Ja(a,b,c,d,e);else{f=c;if(!b)throw Error("Invalid event type");c=!!d;var g=T(a);g||(a[R]=g=new Fa(a));var h=g,u=b.toString(),g=h.a[u];g||(g=h.a[u]=[],h.b++);var p;b:{for(p=0;p<g.length;++p){var n=g[p];if(!n.h&&n.listener==f&&n.j==!!d&&n.b==e)break b}p=-1}-1<p?(d=g[p],d.i=!1):(d=new Da(f,h.src,u,!!d,e),d.i=!1,g.push(d));if(!d.a){e=Ka();d.a=e;e.src=a;e.listener=d;if(a.addEventListener)a.addEventListener(b.toString(),
e,c);else if(a.attachEvent)a.attachEvent(La(b.toString()),e);else throw Error("addEventListener and attachEvent are unavailable.");Ga++}a=d}return a}function Ka(){var a=Ma,b=ya?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}
function Na(a){if("number"!=typeof a&&a&&!a.h){var b=a.src;if(b&&b[Ba])b.a(a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.j):b.detachEvent&&b.detachEvent(La(c),d);Ga--;if(c=T(b)){var d=a.type,e;if(e=d in c.a){e=c.a[d];var f=ja(e,a),g;(g=0<=f)&&Array.prototype.splice.call(e,f,1);e=g}e&&(Ea(a),0==c.a[d].length&&(delete c.a[d],c.b--));0==c.b&&(c.src=null,b[R]=null)}else Ea(a)}}}function La(a){return a in S?S[a]:S[a]="on"+a}
function Oa(a,b,c,d){var e=!0;if(a=T(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.j==c&&!f.h&&(f=Pa(f,d),e=e&&!1!==f)}return e}function Pa(a,b){var c=a.listener,d=a.b||a.src;a.i&&Na(a);return c.call(d,b)}
function Ma(a,b){if(a.h)return!0;if(!ya){var c;if(!(c=b))a:{c=["window","event"];for(var d=k,e;e=c.shift();)if(null!=d[e])d=d[e];else{c=null;break a}c=d}e=c;c=new Q(e,this);d=!0;if(!(0>e.keyCode||void 0!=e.returnValue)){a:{var f=!1;if(0==e.keyCode)try{e.keyCode=-1;break a}catch(u){f=!0}if(f||void 0==e.returnValue)e.returnValue=!0}e=[];for(f=c.a;f;f=f.parentNode)e.push(f);for(var f=a.type,g=e.length-1;0<=g;g--){c.a=e[g];var h=Oa(e[g],f,!0,c),d=d&&h}for(g=0;g<e.length;g++)c.a=e[g],h=Oa(e[g],f,!1,c),
d=d&&h}return d}return Pa(a,new Q(b,this))}function T(a){a=a[R];return a instanceof Fa?a:null}var U="__closure_events_fn_"+(1E9*Math.random()>>>0);function Ia(a){if("function"==l(a))return a;a[U]||(a[U]=function(b){return a.handleEvent(b)});return a[U]};function V(a){q.call(this);this.f=a;this.c={}}m(V,q);var Qa=[];function Ja(a,b,c,d,e){"array"!=l(c)&&(c&&(Qa[0]=c.toString()),c=Qa);for(var f=0;f<c.length;f++){var g=Ha(b,c[f],d||a.handleEvent,e||!1,a.f||a);if(!g)break;a.c[g.u]=g}return a}function Ra(a){ka(a.c,function(a,c){this.c.hasOwnProperty(c)&&Na(a)},a);a.c={}}V.prototype.g=function(){V.s.g.call(this);Ra(this)};V.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented");};var Sa=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;function Ta(a){return a?decodeURI(a):a}var Ua=/#|$/;
function Va(a,b){var c=a.search(Ua),d;a:{d=0;for(var e=b.length;0<=(d=a.indexOf(b,d))&&d<c;){var f=a.charCodeAt(d-1);if(38==f||63==f)if(f=a.charCodeAt(d+e),!f||61==f||38==f||35==f)break a;d+=e+1}d=-1}if(0>d)return null;e=a.indexOf("&",d);if(0>e||e>c)e=c;d+=b.length+1;return decodeURIComponent(a.substr(d,e-d).replace(/\+/g," "))};function W(a){q.call(this);this.c=a||document.body;this.f=new V(this);a=aa(ba,this.f);this.b?a.call(void 0):(this.a||(this.a=[]),this.a.push(a));Ja(this.f,this.c,"click",this.v,void 0)}m(W,q);
W.prototype.v=function(a){if((xa?0==a.b.button:"click"==a.type||a.b.button&Aa[0])&&!(H&&sa&&a.g)&&!a.f)for(var b=a.target;b&&b!=this.c;){if(b.tagName&&"a"==b.tagName.toLowerCase()){var c=b.getAttribute("href")||b.getAttributeNS("http://www.w3.org/1999/xlink","href"),d,e=d=c;try{"www.google.com"==Ta(d.match(Sa)[3]||null)&&"/url"==Ta(d.match(Sa)[5]||null)&&(e=Va(d,"q")||Va(d,"url"))}catch(u){}d=e?e:"";if(c!=d){e=d;c={target:"_blank",noreferrer:!0};b=window;d=void 0;d=e instanceof A?e:ma("undefined"!=
typeof e.href?e.href:String(e));var e=c.target||e.target,f=[],g=void 0;for(g in c)switch(g){case "width":case "height":case "top":case "left":f.push(g+"="+c[g]);break;case "target":case "noreferrer":break;default:f.push(g+"="+(c[g]?1:0))}g=f.join(",");f=void 0;if((y("iPhone")&&!y("iPod")&&!y("iPad")||y("iPad")||y("iPod"))&&b.navigator&&b.navigator.standalone&&e&&"_self"!=e){var g=f=b.document.createElement("A"),h=void 0,h=d instanceof A?d:ma(d);g.href=C(h);f.setAttribute("target",e);c.noreferrer&&
f.setAttribute("rel","noreferrer");c=document.createEvent("MouseEvent");c.initMouseEvent("click",!0,!0,b,1);f.dispatchEvent(c)}else c.noreferrer?(f=b.open("",e,g),b=C(d),f&&(ra&&-1!=b.indexOf(";")&&(b="'"+b.replace(/'/g,"%27")+"'"),f.opener=null,ia.test(b)&&(-1!=b.indexOf("&")&&(b=b.replace(ca,"&amp;")),-1!=b.indexOf("<")&&(b=b.replace(da,"&lt;")),-1!=b.indexOf(">")&&(b=b.replace(ea,"&gt;")),-1!=b.indexOf('"')&&(b=b.replace(fa,"&quot;")),-1!=b.indexOf("'")&&(b=b.replace(ga,"&#39;")),-1!=b.indexOf("\x00")&&
(b=b.replace(ha,"&#0;"))),b=E('<META HTTP-EQUIV="refresh" content="0; url='+b+'">'),f.document.write(b instanceof D&&b.constructor===D&&b.b===oa?b.a:"type_error:SafeHtml"),f.document.close())):b.open(C(d),e,g);a.c();break}}b=b.parentNode}};function Wa(a){new W(a)}var X=["DOCS_installLinkReferrerSanitizer"],Y=k;X[0]in Y||!Y.execScript||Y.execScript("var "+X[0]);for(var Z;X.length&&(Z=X.shift());)X.length||void 0===Wa?Y[Z]?Y=Y[Z]:Y=Y[Z]={}:Y[Z]=Wa; })()
</script>
<script type="text/javascript">DOCS_installLinkReferrerSanitizer();</script></body></html>